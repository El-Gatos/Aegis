import {
  SlashCommandBuilder,
  PermissionFlagsBits,
  ChatInputCommandInteraction,
  MessageFlags,
  EmbedBuilder,
} from "discord.js";
import { Command } from "../../types/command";
import { db } from "../../utils/firebase";
import { sendModLog } from "../../utils/logUtils";
import * as crypto from "crypto";
import * as bcrypt from "bcrypt";

export const command: Command = {
  data: new SlashCommandBuilder()
    .setName("recovery")
    .setDescription("Manage the server recovery token.")
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator)
    .addSubcommand((subcommand) =>
      subcommand
        .setName("setup")
        .setDescription("Generate a new one-time-use recovery token.")
    ),

  async execute(interaction: ChatInputCommandInteraction) {
    if (!interaction.guildId || !interaction.guild) {
      await interaction.reply({
        content: "This command can only be used in a server.",
        flags: [MessageFlags.Ephemeral],
      });
      return;
    }

    if (interaction.user.id !== interaction.guild.ownerId) {
      await interaction.reply({
        content: "❌ Only the server owner can generate a recovery token.",
        flags: [MessageFlags.Ephemeral],
      });
      return;
    }

    await interaction.deferReply({ flags: [MessageFlags.Ephemeral] });

    try {
      const secretKey = crypto.randomBytes(32).toString("hex");

      const fullToken = `${interaction.guildId}.${secretKey}`;

      const salt = await bcrypt.genSalt(10);
      const hash = await bcrypt.hash(secretKey, salt);

      const guildDocRef = db.collection("guilds").doc(interaction.guildId);
      await guildDocRef.set(
        {
          settings: {
            recoveryTokenHash: hash,
          },
        },
        { merge: true }
      );

      try {
        const dmEmbed = new EmbedBuilder()
          .setTitle("Aegis Recovery Token Generated")
          .setDescription(
            `A one-time-use recovery token has been generated for **${interaction.guild.name}**.`
          )
          .addFields(
            { name: "Your Recovery Token", value: `\`\`\`${fullToken}\`\`\`` },
            {
              name: "⚠️ Warning",
              value:
                "Save this token somewhere safe, like a password manager. **Do not share it with anyone.** If you lose it, run this command again to generate a new one. This is your only way to recover admin access if you are locked out.",
            }
          )
          .setColor("Red");

        await interaction.user.send({ embeds: [dmEmbed] });
      } catch (dmError) {
        console.error("Failed to send recovery token DM:", dmError);
        await interaction.editReply({
          content:
            "❌ I tried to generate a token, but I **could not send you a DM**. Please enable your DMs for this server and run the command again.",
        });
        return;
      }

      await interaction.editReply({
        content:
          "✅ A new one-time recovery token has been generated and sent to your DMs. The old one (if any) is now invalid.",
      });

      await sendModLog({
        guild: interaction.guild,
        moderator: interaction.user,
        target: interaction.user,
        action: "Recovery Token Generated",
        actionColor: "Red",
        reason: "A new admin recovery token was generated by the server owner.",
      });
    } catch (error) {
      console.error("Error in recovery command:", error);
      await interaction.editReply({ content: "An unexpected error occurred." });
    }
  },
};

export const data = command.data;
